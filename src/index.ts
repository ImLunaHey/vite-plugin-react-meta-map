import fs from "fs";
import path from "path";
import { pathToFileURL } from "url";
import { build } from "esbuild";
import React from "react";
import ReactDOMServer from "react-dom/server";
import { Plugin } from "vite";
import { OutputBundle, OutputChunk } from "rollup";

interface MetaMapPluginOptions {
  pageTemplateFilePath: string;
  pageMetaMapFilePath: string;
}

function metaMapPlugin(options: MetaMapPluginOptions): Plugin {
  let outputDir: string;
  const generatedEntryChunks: OutputChunk[] = [];

  return {
    name: "vite-plugin-react-meta-map",

    configResolved(resolvedConfig) {
      // get the output directory from Vite config
      outputDir = resolvedConfig.build.outDir;
    },

    generateBundle(_, bundle: OutputBundle) {
      // track entry point assets generated by vite
      for (const [, chunk] of Object.entries(bundle)) {
        if (chunk.type === "chunk") {
          if (chunk.isEntry) generatedEntryChunks.push(chunk);
        }
      }
    },

    async closeBundle() {
      const { pageTemplateFilePath, pageMetaMapFilePath } = options;

      // ensure output directory exists
      const resolvedOutputDir = path.resolve(outputDir);
      if (!fs.existsSync(resolvedOutputDir)) {
        fs.mkdirSync(resolvedOutputDir, { recursive: true });
      }

      // generate temp output directory path for bundled files
      const bundleOutputDir = path.join(
        resolvedOutputDir,
        `temp-bundle-${Date.now()}`
      );

      // bundle user files
      await build({
        entryPoints: [pageTemplateFilePath, pageMetaMapFilePath],
        outdir: bundleOutputDir,
        bundle: true,
        platform: "node",
        format: "esm",
        external: ["react", "react-dom"], // externalize React to avoid bundling it
      });

      // construct the bundled output file URL
      const getFileUrl = (filePath: string) => {
        const { dir, name } = path.parse(filePath);
        const fullPath = path.join(bundleOutputDir, dir, name + ".js");
        return pathToFileURL(fullPath).href;
      };

      // get URLs for both PageTemplate and pages files
      const pageTemplateUrl = getFileUrl(pageTemplateFilePath);
      const pageMetaMapUrl = getFileUrl(pageMetaMapFilePath);

      // import the PageTemplate and pages from their respective files
      const { default: PageTemplate } = await import(pageTemplateUrl);
      const { pages } = await import(pageMetaMapUrl);

      pages.forEach((page: React.ComponentProps<typeof PageTemplate>) => {
        let html = ReactDOMServer.renderToString(
          React.createElement(PageTemplate, page)
        );

        // check if the generated HTML contains ' id="root"'
        if (!html.includes(' id="root"')) {
          throw new Error(
            `Error: The vite-plugin-react-meta-map's PageTemplate does not contain 'id="root"'. Ensure that the PageTemplate renders an element with id="root".`
          );
        }

        // inject the correct assets into the head section
        const htmlStart = html.indexOf("</head>");
        const htmlBeforeHeadClose = html.slice(0, htmlStart);
        const htmlAfterHeadClose = html.slice(htmlStart);

        const assetTags: string[] = [];

        generatedEntryChunks.forEach((chunk) => {
          const isMatchingEntryPoint = Object.keys(chunk.modules).some(
            (modulePath) => {
              const relativeModulePath =
                "/" +
                path.relative(process.cwd(), modulePath).replace(/\\/g, "/");
              return relativeModulePath === page.bundleEntryPoint;
            }
          );
          if (isMatchingEntryPoint) {
            // include script tag for entry chunk
            assetTags.push(
              `<script type="module" crossorigin src="/${chunk.fileName}"></script>`
            );
            // include preload links for imports
            for (const importFile of chunk.imports) {
              assetTags.push(
                `<link rel="modulepreload" crossorigin href="/${importFile}">`
              );
            }
            // include CSS links
            const cssFiles = chunk.viteMetadata?.importedCss || [];
            for (const cssFile of cssFiles) {
              assetTags.push(
                `<link rel="stylesheet" crossorigin href="/${cssFile}">`
              );
            }
          }
        });

        html = htmlBeforeHeadClose + assetTags.join("") + htmlAfterHeadClose;

        const filePath = path.join(resolvedOutputDir, page.url);
        const directoryPath = path.dirname(filePath);

        // ensure the directory exists in case page.url has a subdir
        if (!fs.existsSync(directoryPath)) {
          fs.mkdirSync(directoryPath, { recursive: true });
        }

        fs.writeFileSync(filePath, `<!DOCTYPE html>${html}`, "utf8");
      });

      // clean up the temporary dir using the callback method
      fs.rm(bundleOutputDir, { recursive: true, force: true }, (err) => {
        if (err) {
          console.error(
            `Failed to delete temp directory ${bundleOutputDir}:`,
            err
          );
        }
      });
    },
  };
}

export default metaMapPlugin;
